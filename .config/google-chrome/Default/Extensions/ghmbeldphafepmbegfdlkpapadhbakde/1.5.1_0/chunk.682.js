"use strict";(globalThis.webpackChunkproton_pass_extension=globalThis.webpackChunkproton_pass_extension||[]).push([[682],{2682:(r,y,W)=>{W.r(y),W.d(y,{ByteLengthQueuingStrategy:()=>fr,CountQueuingStrategy:()=>pr,ReadableByteStreamController:()=>fe,ReadableStream:()=>tr,ReadableStreamBYOBReader:()=>Fe,ReadableStreamBYOBRequest:()=>de,ReadableStreamDefaultController:()=>It,ReadableStreamDefaultReader:()=>X,TransformStream:()=>Sr,TransformStreamDefaultController:()=>Er,WritableStream:()=>Ve,WritableStreamDefaultController:()=>_t,WritableStreamDefaultWriter:()=>at}),
/*! OpenPGP.js v5.9.1-0 - 2023-08-03 - this is LGPL licensed code, see LICENSE/our website https://openpgpjs.org/ for more information. */
"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;const j="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?Symbol:r=>`Symbol(${r})`;function t(){}const A="undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:void 0;function o(r){return"object"==typeof r&&null!==r||"function"==typeof r}const z=t,F=Promise,ee=Promise.prototype.then,re=Promise.resolve.bind(F),ie=Promise.reject.bind(F);function u(r){return new F(r)}function c(r){return re(r)}function d(r){return ie(r)}function f(r,y,W){return ee.call(r,y,W)}function h(r,y,W){f(f(r,y,W),void 0,z)}function _(r,y){h(r,y)}function b(r,y){h(r,void 0,y)}function p(r,y,W){return f(r,y,W)}function m(r){f(r,void 0,z)}const ht=(()=>{const r=A&&A.queueMicrotask;if("function"==typeof r)return r;const y=c(void 0);return r=>f(y,r)})();function g(r,y,W){if("function"!=typeof r)throw new TypeError("Argument is not a function");return Function.prototype.apply.call(r,y,W)}function w(r,y,W){try{return c(g(r,y,W))}catch(r){return d(r)}}class v{constructor(){this._cursor=0,this._size=0,this._front={_elements:[],_next:void 0},this._back=this._front,this._cursor=0,this._size=0}get length(){return this._size}push(r){const y=this._back;let W=y;16383===y._elements.length&&(W={_elements:[],_next:void 0}),y._elements.push(r),W!==y&&(this._back=W,y._next=W),++this._size}shift(){const r=this._front;let y=r;const W=this._cursor;let j=W+1;const A=r._elements,z=A[W];return 16384===j&&(y=r._next,j=0),--this._size,this._cursor=j,r!==y&&(this._front=y),A[W]=void 0,z}forEach(r){let y=this._cursor,W=this._front,j=W._elements;for(;!(y===j.length&&void 0===W._next||y===j.length&&(W=W._next,j=W._elements,y=0,0===j.length));)r(j[y]),++y}peek(){const r=this._front,y=this._cursor;return r._elements[y]}}function S(r,y){r._ownerReadableStream=y,y._reader=r,"readable"===y._state?q(r):"closed"===y._state?function(r){q(r),k(r)}(r):E(r,y._storedError)}function R(r,y){return ar(r._ownerReadableStream,y)}function T(r){"readable"===r._ownerReadableStream._state?C(r,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")):function(r,y){E(r,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"))}(r),r._ownerReadableStream._reader=void 0,r._ownerReadableStream=void 0}function P(r){return new TypeError("Cannot "+r+" a stream using a released reader")}function q(r){r._closedPromise=u(((y,W)=>{r._closedPromise_resolve=y,r._closedPromise_reject=W}))}function E(r,y){q(r),C(r,y)}function C(r,y){void 0!==r._closedPromise_reject&&(m(r._closedPromise),r._closedPromise_reject(y),r._closedPromise_resolve=void 0,r._closedPromise_reject=void 0)}function k(r){void 0!==r._closedPromise_resolve&&(r._closedPromise_resolve(void 0),r._closedPromise_resolve=void 0,r._closedPromise_reject=void 0)}const zt=j("[[AbortSteps]]"),Ft=j("[[ErrorSteps]]"),zr=j("[[CancelSteps]]"),Br=j("[[PullSteps]]"),Ir=Number.isFinite||function(r){return"number"==typeof r&&isFinite(r)},Fr=Math.trunc||function(r){return r<0?Math.ceil(r):Math.floor(r)};function B(r,y){if(void 0!==r&&"object"!=typeof(W=r)&&"function"!=typeof W)throw new TypeError(y+" is not an object.");var W}function I(r,y){if("function"!=typeof r)throw new TypeError(y+" is not a function.")}function L(r,y){if(!function(r){return"object"==typeof r&&null!==r||"function"==typeof r}(r))throw new TypeError(y+" is not an object.")}function M(r,y,W){if(void 0===r)throw new TypeError(`Parameter ${y} is required in '${W}'.`)}function $(r,y,W){if(void 0===r)throw new TypeError(`${y} is required in '${W}'.`)}function D(r){return Number(r)}function x(r){return 0===r?0:r}function N(r,y){const W=Number.MAX_SAFE_INTEGER;let j=Number(r);if(j=x(j),!Ir(j))throw new TypeError(y+" is not a finite number");if(j=function(r){return x(Fr(r))}(j),j<0||j>W)throw new TypeError(`${y} is outside the accepted range of 0 to ${W}, inclusive`);return Ir(j)&&0!==j?j:0}function Q(r,y){if(!nr(r))throw new TypeError(y+" is not a ReadableStream.")}function H(r){return new X(r)}function Y(r,y){r._reader._readRequests.push(y)}function V(r,y,W){const j=r._reader._readRequests.shift();W?j._closeSteps():j._chunkSteps(y)}function U(r){return r._reader._readRequests.length}function G(r){const y=r._reader;return void 0!==y&&!!J(y)}class X{constructor(r){if(M(r,1,"ReadableStreamDefaultReader"),Q(r,"First parameter"),ir(r))throw new TypeError("This stream has already been locked for exclusive reading by another reader");S(this,r),this._readRequests=new v}get closed(){return J(this)?this._closedPromise:d(Z("closed"))}cancel(r=void 0){return J(this)?void 0===this._ownerReadableStream?d(P("cancel")):R(this,r):d(Z("cancel"))}read(){if(!J(this))return d(Z("read"));if(void 0===this._ownerReadableStream)return d(P("read from"));let r,y;const W=u(((W,j)=>{r=W,y=j}));return K(this,{_chunkSteps:y=>r({value:y,done:!1}),_closeSteps:()=>r({value:void 0,done:!0}),_errorSteps:r=>y(r)}),W}releaseLock(){if(!J(this))throw Z("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");T(this)}}}function J(r){return!!o(r)&&!!Object.prototype.hasOwnProperty.call(r,"_readRequests")}function K(r,y){const W=r._ownerReadableStream;W._disturbed=!0,"closed"===W._state?y._closeSteps():"errored"===W._state?y._errorSteps(W._storedError):W._readableStreamController[Br](y)}function Z(r){return new TypeError(`ReadableStreamDefaultReader.prototype.${r} can only be used on a ReadableStreamDefaultReader`)}let Lr;Object.defineProperties(X.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),"symbol"==typeof j.toStringTag&&Object.defineProperty(X.prototype,j.toStringTag,{value:"ReadableStreamDefaultReader",configurable:!0}),"symbol"==typeof j.asyncIterator&&(Lr={[j.asyncIterator](){return this}},Object.defineProperty(Lr,j.asyncIterator,{enumerable:!1}));class te{constructor(r,y){this._ongoingPromise=void 0,this._isFinished=!1,this._reader=r,this._preventCancel=y}next(){const e=()=>this._nextSteps();return this._ongoingPromise=this._ongoingPromise?p(this._ongoingPromise,e,e):e(),this._ongoingPromise}return(r){const t=()=>this._returnSteps(r);return this._ongoingPromise?p(this._ongoingPromise,t,t):t()}_nextSteps(){if(this._isFinished)return Promise.resolve({value:void 0,done:!0});const r=this._reader;if(void 0===r._ownerReadableStream)return d(P("iterate"));let y,W;const j=u(((r,j)=>{y=r,W=j}));return K(r,{_chunkSteps:r=>{this._ongoingPromise=void 0,ht((()=>y({value:r,done:!1})))},_closeSteps:()=>{this._ongoingPromise=void 0,this._isFinished=!0,T(r),y({value:void 0,done:!0})},_errorSteps:y=>{this._ongoingPromise=void 0,this._isFinished=!0,T(r),W(y)}}),j}_returnSteps(r){if(this._isFinished)return Promise.resolve({value:r,done:!0});this._isFinished=!0;const y=this._reader;if(void 0===y._ownerReadableStream)return d(P("finish iterating"));if(!this._preventCancel){const W=R(y,r);return T(y),p(W,(()=>({value:r,done:!0})))}return T(y),c({value:r,done:!0})}}const Mr={next(){return oe(this)?this._asyncIteratorImpl.next():d(ne("next"))},return(r){return oe(this)?this._asyncIteratorImpl.return(r):d(ne("return"))}};function oe(r){return!!o(r)&&!!Object.prototype.hasOwnProperty.call(r,"_asyncIteratorImpl")}function ne(r){return new TypeError(`ReadableStreamAsyncIterator.${r} can only be used on a ReadableSteamAsyncIterator`)}void 0!==Lr&&Object.setPrototypeOf(Mr,Lr);const $r=Number.isNaN||function(r){return r!=r};function ae(r){return!!function(r){return"number"==typeof r&&(!$r(r)&&!(r<0))}(r)&&r!==1/0}function se(r){const y=r._queue.shift();return r._queueTotalSize-=y.size,r._queueTotalSize<0&&(r._queueTotalSize=0),y.value}function le(r,y,W){if(!ae(W=Number(W)))throw new RangeError("Size must be a finite, non-NaN, non-negative number.");r._queue.push({value:y,size:W}),r._queueTotalSize+=W}function ue(r){r._queue=new v,r._queueTotalSize=0}function ce(r){return r.slice()}class de{constructor(){throw new TypeError("Illegal constructor")}get view(){if(!_e(this))throw Oe("view");return this._view}respond(r){if(!_e(this))throw Oe("respond");if(M(r,1,"respond"),r=N(r,"First parameter"),void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");this._view.buffer,function(r,y){if(!ae(y=Number(y)))throw new RangeError("bytesWritten must be a finite");Te(r,y)}(this._associatedReadableByteStreamController,r)}respondWithNewView(r){if(!_e(this))throw Oe("respondWithNewView");if(M(r,1,"respondWithNewView"),!ArrayBuffer.isView(r))throw new TypeError("You can only respond with array buffer views");if(0===r.byteLength)throw new TypeError("chunk must have non-zero byteLength");if(0===r.buffer.byteLength)throw new TypeError("chunk's buffer must have non-zero byteLength");if(void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");!function(r,y){const W=r._pendingPullIntos.peek();if(W.byteOffset+W.bytesFilled!==y.byteOffset)throw new RangeError("The region specified by view does not match byobRequest");if(W.byteLength!==y.byteLength)throw new RangeError("The buffer of view has different capacity than byobRequest");W.buffer=y.buffer,Te(r,y.byteLength)}(this._associatedReadableByteStreamController,r)}}Object.defineProperties(de.prototype,{respond:{enumerable:!0},respondWithNewView:{enumerable:!0},view:{enumerable:!0}}),"symbol"==typeof j.toStringTag&&Object.defineProperty(de.prototype,j.toStringTag,{value:"ReadableStreamBYOBRequest",configurable:!0});class fe{constructor(){throw new TypeError("Illegal constructor")}get byobRequest(){if(!he(this))throw je("byobRequest");if(null===this._byobRequest&&this._pendingPullIntos.length>0){const r=this._pendingPullIntos.peek(),y=new Uint8Array(r.buffer,r.byteOffset+r.bytesFilled,r.byteLength-r.bytesFilled),W=Object.create(de.prototype);!function(r,y,W){r._associatedReadableByteStreamController=y,r._view=W}(W,this,y),this._byobRequest=W}return this._byobRequest}get desiredSize(){if(!he(this))throw je("desiredSize");return Ce(this)}close(){if(!he(this))throw je("close");if(this._closeRequested)throw new TypeError("The stream has already been closed; do not close it again!");const r=this._controlledReadableByteStream._state;if("readable"!==r)throw new TypeError(`The stream (in ${r} state) is not in the readable state and cannot be closed`);!function(r){const y=r._controlledReadableByteStream;if(!r._closeRequested&&"readable"===y._state)if(r._queueTotalSize>0)r._closeRequested=!0;else{if(r._pendingPullIntos.length>0&&r._pendingPullIntos.peek().bytesFilled>0){const y=new TypeError("Insufficient bytes to fill elements in the given buffer");throw Ee(r,y),y}qe(r),sr(y)}}(this)}enqueue(r){if(!he(this))throw je("enqueue");if(M(r,1,"enqueue"),!ArrayBuffer.isView(r))throw new TypeError("chunk must be an array buffer view");if(0===r.byteLength)throw new TypeError("chunk must have non-zero byteLength");if(0===r.buffer.byteLength)throw new TypeError("chunk's buffer must have non-zero byteLength");if(this._closeRequested)throw new TypeError("stream is closed or draining");const y=this._controlledReadableByteStream._state;if("readable"!==y)throw new TypeError(`The stream (in ${y} state) is not in the readable state and cannot be enqueued to`);!function(r,y){const W=r._controlledReadableByteStream;if(r._closeRequested||"readable"!==W._state)return;const j=y.buffer,A=y.byteOffset,z=y.byteLength,F=j;G(W)?0===U(W)?ye(r,F,A,z):V(W,new Uint8Array(F,A,z),!1):ze(W)?(ye(r,F,A,z),Re(r)):ye(r,F,A,z),be(r)}(this,r)}error(r=void 0){if(!he(this))throw je("error");Ee(this,r)}[zr](r){this._pendingPullIntos.length>0&&(this._pendingPullIntos.peek().bytesFilled=0),ue(this);const y=this._cancelAlgorithm(r);return qe(this),y}[Br](r){const y=this._controlledReadableByteStream;if(this._queueTotalSize>0){const y=this._queue.shift();this._queueTotalSize-=y.byteLength,ve(this);const W=new Uint8Array(y.buffer,y.byteOffset,y.byteLength);return void r._chunkSteps(W)}const W=this._autoAllocateChunkSize;if(void 0!==W){let j;try{j=new ArrayBuffer(W)}catch(y){return void r._errorSteps(y)}const A={buffer:j,byteOffset:0,byteLength:W,bytesFilled:0,elementSize:1,viewConstructor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(A)}Y(y,r),be(this)}}function he(r){return!!o(r)&&!!Object.prototype.hasOwnProperty.call(r,"_controlledReadableByteStream")}function _e(r){return!!o(r)&&!!Object.prototype.hasOwnProperty.call(r,"_associatedReadableByteStreamController")}function be(r){const y=function(r){const y=r._controlledReadableByteStream;if("readable"!==y._state)return!1;if(r._closeRequested)return!1;if(!r._started)return!1;if(G(y)&&U(y)>0)return!0;if(ze(y)&&Ae(y)>0)return!0;return Ce(r)>0}(r);y&&(r._pulling?r._pullAgain=!0:(r._pulling=!0,h(r._pullAlgorithm(),(()=>{r._pulling=!1,r._pullAgain&&(r._pullAgain=!1,be(r))}),(y=>{Ee(r,y)}))))}function pe(r,y){let W=!1;"closed"===r._state&&(W=!0);const j=me(y);"default"===y.readerType?V(r,j,W):function(r,y,W){const j=r._reader._readIntoRequests.shift();W?j._closeSteps(y):j._chunkSteps(y)}(r,j,W)}function me(r){const y=r.bytesFilled,W=r.elementSize;return new r.viewConstructor(r.buffer,r.byteOffset,y/W)}function ye(r,y,W,j){r._queue.push({buffer:y,byteOffset:W,byteLength:j}),r._queueTotalSize+=j}function ge(r,y){const W=y.elementSize,j=y.bytesFilled-y.bytesFilled%W,A=Math.min(r._queueTotalSize,y.byteLength-y.bytesFilled),z=y.bytesFilled+A,F=z-z%W;let ee=A,re=!1;F>j&&(ee=F-y.bytesFilled,re=!0);const ie=r._queue;for(;ee>0;){const W=ie.peek(),j=Math.min(ee,W.byteLength),A=y.byteOffset+y.bytesFilled;ht=y.buffer,zt=A,Ft=W.buffer,zr=W.byteOffset,Br=j,new Uint8Array(ht).set(new Uint8Array(Ft,zr,Br),zt),W.byteLength===j?ie.shift():(W.byteOffset+=j,W.byteLength-=j),r._queueTotalSize-=j,we(r,j,y),ee-=j}var ht,zt,Ft,zr,Br;return re}function we(r,y,W){Se(r),W.bytesFilled+=y}function ve(r){0===r._queueTotalSize&&r._closeRequested?(qe(r),sr(r._controlledReadableByteStream)):be(r)}function Se(r){null!==r._byobRequest&&(r._byobRequest._associatedReadableByteStreamController=void 0,r._byobRequest._view=null,r._byobRequest=null)}function Re(r){for(;r._pendingPullIntos.length>0;){if(0===r._queueTotalSize)return;const y=r._pendingPullIntos.peek();ge(r,y)&&(Pe(r),pe(r._controlledReadableByteStream,y))}}function Te(r,y){const W=r._pendingPullIntos.peek();if("closed"===r._controlledReadableByteStream._state){if(0!==y)throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");!function(r,y){y.buffer=y.buffer;const W=r._controlledReadableByteStream;if(ze(W))for(;Ae(W)>0;)pe(W,Pe(r))}(r,W)}else!function(r,y,W){if(W.bytesFilled+y>W.byteLength)throw new RangeError("bytesWritten out of range");if(we(r,y,W),W.bytesFilled<W.elementSize)return;Pe(r);const j=W.bytesFilled%W.elementSize;if(j>0){const y=W.byteOffset+W.bytesFilled,A=W.buffer.slice(y-j,y);ye(r,A,0,A.byteLength)}W.buffer=W.buffer,W.bytesFilled-=j,pe(r._controlledReadableByteStream,W),Re(r)}(r,y,W);be(r)}function Pe(r){const y=r._pendingPullIntos.shift();return Se(r),y}function qe(r){r._pullAlgorithm=void 0,r._cancelAlgorithm=void 0}function Ee(r,y){const W=r._controlledReadableByteStream;"readable"===W._state&&(function(r){Se(r),r._pendingPullIntos=new v}(r),ue(r),qe(r),lr(W,y))}function Ce(r){const y=r._controlledReadableByteStream._state;return"errored"===y?null:"closed"===y?0:r._strategyHWM-r._queueTotalSize}function Oe(r){return new TypeError(`ReadableStreamBYOBRequest.prototype.${r} can only be used on a ReadableStreamBYOBRequest`)}function je(r){return new TypeError(`ReadableByteStreamController.prototype.${r} can only be used on a ReadableByteStreamController`)}function We(r,y){r._reader._readIntoRequests.push(y)}function Ae(r){return r._reader._readIntoRequests.length}function ze(r){const y=r._reader;return void 0!==y&&!!Be(y)}Object.defineProperties(fe.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},byobRequest:{enumerable:!0},desiredSize:{enumerable:!0}}),"symbol"==typeof j.toStringTag&&Object.defineProperty(fe.prototype,j.toStringTag,{value:"ReadableByteStreamController",configurable:!0});class Fe{constructor(r){if(M(r,1,"ReadableStreamBYOBReader"),Q(r,"First parameter"),ir(r))throw new TypeError("This stream has already been locked for exclusive reading by another reader");if(!he(r._readableStreamController))throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");S(this,r),this._readIntoRequests=new v}get closed(){return Be(this)?this._closedPromise:d(Ie("closed"))}cancel(r=void 0){return Be(this)?void 0===this._ownerReadableStream?d(P("cancel")):R(this,r):d(Ie("cancel"))}read(r){if(!Be(this))return d(Ie("read"));if(!ArrayBuffer.isView(r))return d(new TypeError("view must be an array buffer view"));if(0===r.byteLength)return d(new TypeError("view must have non-zero byteLength"));if(0===r.buffer.byteLength)return d(new TypeError("view's buffer must have non-zero byteLength"));if(void 0===this._ownerReadableStream)return d(P("read from"));let y,W;const j=u(((r,j)=>{y=r,W=j}));return function(r,y,W){const j=r._ownerReadableStream;j._disturbed=!0,"errored"===j._state?W._errorSteps(j._storedError):function(r,y,W){const j=r._controlledReadableByteStream;let A=1;y.constructor!==DataView&&(A=y.constructor.BYTES_PER_ELEMENT);const z=y.constructor,F={buffer:y.buffer,byteOffset:y.byteOffset,byteLength:y.byteLength,bytesFilled:0,elementSize:A,viewConstructor:z,readerType:"byob"};if(r._pendingPullIntos.length>0)return r._pendingPullIntos.push(F),void We(j,W);if("closed"!==j._state){if(r._queueTotalSize>0){if(ge(r,F)){const y=me(F);return ve(r),void W._chunkSteps(y)}if(r._closeRequested){const y=new TypeError("Insufficient bytes to fill elements in the given buffer");return Ee(r,y),void W._errorSteps(y)}}r._pendingPullIntos.push(F),We(j,W),be(r)}else{const r=new z(F.buffer,F.byteOffset,0);W._closeSteps(r)}}(j._readableStreamController,y,W)}(this,r,{_chunkSteps:r=>y({value:r,done:!1}),_closeSteps:r=>y({value:r,done:!0}),_errorSteps:r=>W(r)}),j}releaseLock(){if(!Be(this))throw Ie("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readIntoRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");T(this)}}}function Be(r){return!!o(r)&&!!Object.prototype.hasOwnProperty.call(r,"_readIntoRequests")}function Ie(r){return new TypeError(`ReadableStreamBYOBReader.prototype.${r} can only be used on a ReadableStreamBYOBReader`)}function Le(r,y){const{highWaterMark:W}=r;if(void 0===W)return y;if($r(W)||W<0)throw new RangeError("Invalid highWaterMark");return W}function Me(r){const{size:y}=r;return y||(()=>1)}function $e(r,y){B(r,y);const W=null==r?void 0:r.highWaterMark,j=null==r?void 0:r.size;return{highWaterMark:void 0===W?void 0:D(W),size:void 0===j?void 0:De(j,y+" has member 'size' that")}}function De(r,y){return I(r,y),y=>D(r(y))}function xe(r,y,W){return I(r,W),W=>w(r,y,[W])}function Ne(r,y,W){return I(r,W),()=>w(r,y,[])}function Qe(r,y,W){return I(r,W),W=>g(r,y,[W])}function He(r,y,W){return I(r,W),(W,j)=>w(r,y,[W,j])}function Ye(r,y){if(!Xe(r))throw new TypeError(y+" is not a WritableStream.")}Object.defineProperties(Fe.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),"symbol"==typeof j.toStringTag&&Object.defineProperty(Fe.prototype,j.toStringTag,{value:"ReadableStreamBYOBReader",configurable:!0});class Ve{constructor(r={},y={}){void 0===r?r=null:L(r,"First parameter");const W=$e(y,"Second parameter"),j=function(r,y){B(r,y);const W=null==r?void 0:r.abort,j=null==r?void 0:r.close,A=null==r?void 0:r.start,z=null==r?void 0:r.type,F=null==r?void 0:r.write;return{abort:void 0===W?void 0:xe(W,r,y+" has member 'abort' that"),close:void 0===j?void 0:Ne(j,r,y+" has member 'close' that"),start:void 0===A?void 0:Qe(A,r,y+" has member 'start' that"),write:void 0===F?void 0:He(F,r,y+" has member 'write' that"),type:z}}(r,"First parameter");if(Ge(this),void 0!==j.type)throw new RangeError("Invalid type is specified");const A=Me(W);!function(r,y,W,j){const A=Object.create(_t.prototype);let i=()=>{},a=()=>c(void 0),s=()=>c(void 0),l=()=>c(void 0);void 0!==y.start&&(i=()=>y.start(A)),void 0!==y.write&&(a=r=>y.write(r,A)),void 0!==y.close&&(s=()=>y.close()),void 0!==y.abort&&(l=r=>y.abort(r)),bt(r,A,i,a,s,l,W,j)}(this,j,Le(W,1),A)}get locked(){if(!Xe(this))throw St("locked");return Je(this)}abort(r=void 0){return Xe(this)?Je(this)?d(new TypeError("Cannot abort a stream that already has a writer")):Ke(this,r):d(St("abort"))}close(){return Xe(this)?Je(this)?d(new TypeError("Cannot close a stream that already has a writer")):ot(this)?d(new TypeError("Cannot close an already-closing stream")):Ze(this):d(St("close"))}getWriter(){if(!Xe(this))throw St("getWriter");return Ue(this)}}function Ue(r){return new at(r)}function Ge(r){r._state="writable",r._storedError=void 0,r._writer=void 0,r._writableStreamController=void 0,r._writeRequests=new v,r._inFlightWriteRequest=void 0,r._closeRequest=void 0,r._inFlightCloseRequest=void 0,r._pendingAbortRequest=void 0,r._backpressure=!1}function Xe(r){return!!o(r)&&!!Object.prototype.hasOwnProperty.call(r,"_writableStreamController")}function Je(r){return void 0!==r._writer}function Ke(r,y){const W=r._state;if("closed"===W||"errored"===W)return c(void 0);if(void 0!==r._pendingAbortRequest)return r._pendingAbortRequest._promise;let j=!1;"erroring"===W&&(j=!0,y=void 0);const A=u(((W,A)=>{r._pendingAbortRequest={_promise:void 0,_resolve:W,_reject:A,_reason:y,_wasAlreadyErroring:j}}));return r._pendingAbortRequest._promise=A,j||tt(r,y),A}function Ze(r){const y=r._state;if("closed"===y||"errored"===y)return d(new TypeError(`The stream (in ${y} state) is not in the writable state and cannot be closed`));const W=u(((y,W)=>{const j={_resolve:y,_reject:W};r._closeRequest=j})),j=r._writer;var A;return void 0!==j&&r._backpressure&&"writable"===y&&At(j),le(A=r._writableStreamController,Dr,0),yt(A),W}function et(r,y){"writable"!==r._state?rt(r):tt(r,y)}function tt(r,y){const W=r._writableStreamController;r._state="erroring",r._storedError=y;const j=r._writer;void 0!==j&&ct(j,y),!function(r){return void 0!==r._inFlightWriteRequest||void 0!==r._inFlightCloseRequest}(r)&&W._started&&rt(r)}function rt(r){r._state="errored",r._writableStreamController[Ft]();const y=r._storedError;if(r._writeRequests.forEach((r=>{r._reject(y)})),r._writeRequests=new v,void 0===r._pendingAbortRequest)return void nt(r);const W=r._pendingAbortRequest;if(r._pendingAbortRequest=void 0,W._wasAlreadyErroring)return W._reject(y),void nt(r);h(r._writableStreamController[zt](W._reason),(()=>{W._resolve(),nt(r)}),(y=>{W._reject(y),nt(r)}))}function ot(r){return void 0!==r._closeRequest||void 0!==r._inFlightCloseRequest}function nt(r){void 0!==r._closeRequest&&(r._closeRequest._reject(r._storedError),r._closeRequest=void 0);const y=r._writer;void 0!==y&&Et(y,r._storedError)}function it(r,y){const W=r._writer;void 0!==W&&y!==r._backpressure&&(y?function(r){kt(r)}(W):At(W)),r._backpressure=y}Object.defineProperties(Ve.prototype,{abort:{enumerable:!0},close:{enumerable:!0},getWriter:{enumerable:!0},locked:{enumerable:!0}}),"symbol"==typeof j.toStringTag&&Object.defineProperty(Ve.prototype,j.toStringTag,{value:"WritableStream",configurable:!0});class at{constructor(r){if(M(r,1,"WritableStreamDefaultWriter"),Ye(r,"First parameter"),Je(r))throw new TypeError("This stream has already been locked for exclusive writing by another writer");this._ownerWritableStream=r,r._writer=this;const y=r._state;if("writable"===y)!ot(r)&&r._backpressure?kt(this):jt(this),Pt(this);else if("erroring"===y)Ot(this,r._storedError),Pt(this);else if("closed"===y)jt(this),Pt(this),Ct(this);else{const y=r._storedError;Ot(this,y),qt(this,y)}}get closed(){return st(this)?this._closedPromise:d(Rt("closed"))}get desiredSize(){if(!st(this))throw Rt("desiredSize");if(void 0===this._ownerWritableStream)throw Tt("desiredSize");return function(r){const y=r._ownerWritableStream,W=y._state;return"errored"===W||"erroring"===W?null:"closed"===W?0:mt(y._writableStreamController)}(this)}get ready(){return st(this)?this._readyPromise:d(Rt("ready"))}abort(r=void 0){return st(this)?void 0===this._ownerWritableStream?d(Tt("abort")):function(r,y){return Ke(r._ownerWritableStream,y)}(this,r):d(Rt("abort"))}close(){if(!st(this))return d(Rt("close"));const r=this._ownerWritableStream;return void 0===r?d(Tt("close")):ot(r)?d(new TypeError("Cannot close an already-closing stream")):lt(this)}releaseLock(){if(!st(this))throw Rt("releaseLock");void 0!==this._ownerWritableStream&&dt(this)}write(r=void 0){return st(this)?void 0===this._ownerWritableStream?d(Tt("write to")):ft(this,r):d(Rt("write"))}}function st(r){return!!o(r)&&!!Object.prototype.hasOwnProperty.call(r,"_ownerWritableStream")}function lt(r){return Ze(r._ownerWritableStream)}function ct(r,y){"pending"===r._readyPromiseState?Wt(r,y):function(r,y){Ot(r,y)}(r,y)}function dt(r){const y=r._ownerWritableStream,W=new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");ct(r,W),function ut(r,y){"pending"===r._closedPromiseState?Et(r,y):function(r,y){qt(r,y)}(r,y)}(r,W),y._writer=void 0,r._ownerWritableStream=void 0}function ft(r,y){const W=r._ownerWritableStream,j=W._writableStreamController,A=function(r,y){try{return r._strategySizeAlgorithm(y)}catch(y){return gt(r,y),1}}(j,y);if(W!==r._ownerWritableStream)return d(Tt("write to"));const z=W._state;if("errored"===z)return d(W._storedError);if(ot(W)||"closed"===z)return d(new TypeError("The stream is closing or closed and cannot be written to"));if("erroring"===z)return d(W._storedError);const F=function(r){return u(((y,W)=>{const j={_resolve:y,_reject:W};r._writeRequests.push(j)}))}(W);return function(r,y,W){try{le(r,y,W)}catch(y){return void gt(r,y)}const j=r._controlledWritableStream;ot(j)||"writable"!==j._state||it(j,wt(r)),yt(r)}(j,y,A),F}Object.defineProperties(at.prototype,{abort:{enumerable:!0},close:{enumerable:!0},releaseLock:{enumerable:!0},write:{enumerable:!0},closed:{enumerable:!0},desiredSize:{enumerable:!0},ready:{enumerable:!0}}),"symbol"==typeof j.toStringTag&&Object.defineProperty(at.prototype,j.toStringTag,{value:"WritableStreamDefaultWriter",configurable:!0});const Dr={};class _t{constructor(){throw new TypeError("Illegal constructor")}error(r=void 0){if(!function(r){return!!o(r)&&!!Object.prototype.hasOwnProperty.call(r,"_controlledWritableStream")}(this))throw new TypeError("WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController");"writable"===this._controlledWritableStream._state&&vt(this,r)}[zt](r){const y=this._abortAlgorithm(r);return pt(this),y}[Ft](){ue(this)}}function bt(r,y,W,j,A,z,F,ee){y._controlledWritableStream=r,r._writableStreamController=y,y._queue=void 0,y._queueTotalSize=void 0,ue(y),y._started=!1,y._strategySizeAlgorithm=ee,y._strategyHWM=F,y._writeAlgorithm=j,y._closeAlgorithm=A,y._abortAlgorithm=z;const re=wt(y);it(r,re),h(c(W()),(()=>{y._started=!0,yt(y)}),(W=>{y._started=!0,et(r,W)}))}function pt(r){r._writeAlgorithm=void 0,r._closeAlgorithm=void 0,r._abortAlgorithm=void 0,r._strategySizeAlgorithm=void 0}function mt(r){return r._strategyHWM-r._queueTotalSize}function yt(r){const y=r._controlledWritableStream;if(!r._started)return;if(void 0!==y._inFlightWriteRequest)return;if("erroring"===y._state)return void rt(y);if(0===r._queue.length)return;const W=r._queue.peek().value;W===Dr?function(r){const y=r._controlledWritableStream;(function(r){r._inFlightCloseRequest=r._closeRequest,r._closeRequest=void 0})(y),se(r);const W=r._closeAlgorithm();pt(r),h(W,(()=>{!function(r){r._inFlightCloseRequest._resolve(void 0),r._inFlightCloseRequest=void 0,"erroring"===r._state&&(r._storedError=void 0,void 0!==r._pendingAbortRequest&&(r._pendingAbortRequest._resolve(),r._pendingAbortRequest=void 0)),r._state="closed";const y=r._writer;void 0!==y&&Ct(y)}(y)}),(r=>{!function(r,y){r._inFlightCloseRequest._reject(y),r._inFlightCloseRequest=void 0,void 0!==r._pendingAbortRequest&&(r._pendingAbortRequest._reject(y),r._pendingAbortRequest=void 0),et(r,y)}(y,r)}))}(r):function(r,y){const W=r._controlledWritableStream;!function(r){r._inFlightWriteRequest=r._writeRequests.shift()}(W);h(r._writeAlgorithm(y),(()=>{!function(r){r._inFlightWriteRequest._resolve(void 0),r._inFlightWriteRequest=void 0}(W);const y=W._state;if(se(r),!ot(W)&&"writable"===y){const y=wt(r);it(W,y)}yt(r)}),(y=>{"writable"===W._state&&pt(r),function(r,y){r._inFlightWriteRequest._reject(y),r._inFlightWriteRequest=void 0,et(r,y)}(W,y)}))}(r,W)}function gt(r,y){"writable"===r._controlledWritableStream._state&&vt(r,y)}function wt(r){return mt(r)<=0}function vt(r,y){const W=r._controlledWritableStream;pt(r),tt(W,y)}function St(r){return new TypeError(`WritableStream.prototype.${r} can only be used on a WritableStream`)}function Rt(r){return new TypeError(`WritableStreamDefaultWriter.prototype.${r} can only be used on a WritableStreamDefaultWriter`)}function Tt(r){return new TypeError("Cannot "+r+" a stream using a released writer")}function Pt(r){r._closedPromise=u(((y,W)=>{r._closedPromise_resolve=y,r._closedPromise_reject=W,r._closedPromiseState="pending"}))}function qt(r,y){Pt(r),Et(r,y)}function Et(r,y){void 0!==r._closedPromise_reject&&(m(r._closedPromise),r._closedPromise_reject(y),r._closedPromise_resolve=void 0,r._closedPromise_reject=void 0,r._closedPromiseState="rejected")}function Ct(r){void 0!==r._closedPromise_resolve&&(r._closedPromise_resolve(void 0),r._closedPromise_resolve=void 0,r._closedPromise_reject=void 0,r._closedPromiseState="resolved")}function kt(r){r._readyPromise=u(((y,W)=>{r._readyPromise_resolve=y,r._readyPromise_reject=W})),r._readyPromiseState="pending"}function Ot(r,y){kt(r),Wt(r,y)}function jt(r){kt(r),At(r)}function Wt(r,y){void 0!==r._readyPromise_reject&&(m(r._readyPromise),r._readyPromise_reject(y),r._readyPromise_resolve=void 0,r._readyPromise_reject=void 0,r._readyPromiseState="rejected")}function At(r){void 0!==r._readyPromise_resolve&&(r._readyPromise_resolve(void 0),r._readyPromise_resolve=void 0,r._readyPromise_reject=void 0,r._readyPromiseState="fulfilled")}Object.defineProperties(_t.prototype,{error:{enumerable:!0}}),"symbol"==typeof j.toStringTag&&Object.defineProperty(_t.prototype,j.toStringTag,{value:"WritableStreamDefaultController",configurable:!0});const Qr="undefined"!=typeof DOMException?DOMException:void 0,xr=function(r){if("function"!=typeof r&&"object"!=typeof r)return!1;try{return new r,!0}catch(r){return!1}}(Qr)?Qr:function(){const e=function(r,y){this.message=r||"",this.name=y||"Error",Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)};return Object.defineProperty(e.prototype=Object.create(Error.prototype),"constructor",{value:e,writable:!0,configurable:!0}),e}();function Bt(r,y,W,j,A,z){const F=H(r),ee=Ue(y);r._disturbed=!0;let re=!1,ie=c(void 0);return u(((ht,zt)=>{let Ft;if(void 0!==z){if(Ft=()=>{const W=new xr("Aborted","AbortError"),z=[];j||z.push((()=>"writable"===y._state?Ke(y,W):c(void 0))),A||z.push((()=>"readable"===r._state?ar(r,W):c(void 0))),C((()=>Promise.all(z.map((r=>r())))),!0,W)},z.aborted)return void Ft();z.addEventListener("abort",Ft)}var zr,Br,Ir;if(E(r,F._closedPromise,(r=>{j?k(!0,r):C((()=>Ke(y,r)),!0,r)})),E(y,ee._closedPromise,(y=>{A?k(!0,y):C((()=>ar(r,y)),!0,y)})),zr=r,Br=F._closedPromise,Ir=()=>{W?k():C((()=>function(r){const y=r._ownerWritableStream,W=y._state;return ot(y)||"closed"===W?c(void 0):"errored"===W?d(y._storedError):lt(r)}(ee)))},"closed"===zr._state?Ir():_(Br,Ir),ot(y)||"closed"===y._state){const y=new TypeError("the destination writable stream closed before all data could be piped to it");A?k(!0,y):C((()=>ar(r,y)),!0,y)}function q(){const r=ie;return f(ie,(()=>r!==ie?q():void 0))}function E(r,y,W){"errored"===r._state?W(r._storedError):b(y,W)}function C(r,W,j){function n(){h(r(),(()=>O(W,j)),(r=>O(!0,r)))}re||(re=!0,"writable"!==y._state||ot(y)?n():_(q(),n))}function k(r,W){re||(re=!0,"writable"!==y._state||ot(y)?O(r,W):_(q(),(()=>O(r,W))))}function O(r,y){dt(ee),T(F),void 0!==z&&z.removeEventListener("abort",Ft),r?zt(y):ht(void 0)}m(u(((r,y)=>{!function o(W){W?r():f(re?c(!0):f(ee._readyPromise,(()=>u(((r,y)=>{K(F,{_chunkSteps:y=>{ie=f(ft(ee,y),void 0,t),r(!1)},_closeSteps:()=>r(!0),_errorSteps:y})})))),o,y)}(!1)})))}))}class It{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!Lt(this))throw Ut("desiredSize");return Ht(this)}close(){if(!Lt(this))throw Ut("close");if(!Yt(this))throw new TypeError("The stream is not in a state that permits close");xt(this)}enqueue(r=void 0){if(!Lt(this))throw Ut("enqueue");if(!Yt(this))throw new TypeError("The stream is not in a state that permits enqueue");return Nt(this,r)}error(r=void 0){if(!Lt(this))throw Ut("error");Qt(this,r)}[zr](r){ue(this);const y=this._cancelAlgorithm(r);return Dt(this),y}[Br](r){const y=this._controlledReadableStream;if(this._queue.length>0){const W=se(this);this._closeRequested&&0===this._queue.length?(Dt(this),sr(y)):Mt(this),r._chunkSteps(W)}else Y(y,r),Mt(this)}}function Lt(r){return!!o(r)&&!!Object.prototype.hasOwnProperty.call(r,"_controlledReadableStream")}function Mt(r){$t(r)&&(r._pulling?r._pullAgain=!0:(r._pulling=!0,h(r._pullAlgorithm(),(()=>{r._pulling=!1,r._pullAgain&&(r._pullAgain=!1,Mt(r))}),(y=>{Qt(r,y)}))))}function $t(r){const y=r._controlledReadableStream;return!!Yt(r)&&(!!r._started&&(!!(ir(y)&&U(y)>0)||Ht(r)>0))}function Dt(r){r._pullAlgorithm=void 0,r._cancelAlgorithm=void 0,r._strategySizeAlgorithm=void 0}function xt(r){if(!Yt(r))return;const y=r._controlledReadableStream;r._closeRequested=!0,0===r._queue.length&&(Dt(r),sr(y))}function Nt(r,y){if(!Yt(r))return;const W=r._controlledReadableStream;if(ir(W)&&U(W)>0)V(W,y,!1);else{let W;try{W=r._strategySizeAlgorithm(y)}catch(y){throw Qt(r,y),y}try{le(r,y,W)}catch(y){throw Qt(r,y),y}}Mt(r)}function Qt(r,y){const W=r._controlledReadableStream;"readable"===W._state&&(ue(r),Dt(r),lr(W,y))}function Ht(r){const y=r._controlledReadableStream._state;return"errored"===y?null:"closed"===y?0:r._strategyHWM-r._queueTotalSize}function Yt(r){const y=r._controlledReadableStream._state;return!r._closeRequested&&"readable"===y}function Vt(r,y,W,j,A,z,F){y._controlledReadableStream=r,y._queue=void 0,y._queueTotalSize=void 0,ue(y),y._started=!1,y._closeRequested=!1,y._pullAgain=!1,y._pulling=!1,y._strategySizeAlgorithm=F,y._strategyHWM=z,y._pullAlgorithm=j,y._cancelAlgorithm=A,r._readableStreamController=y,h(c(W()),(()=>{y._started=!0,Mt(y)}),(r=>{Qt(y,r)}))}function Ut(r){return new TypeError(`ReadableStreamDefaultController.prototype.${r} can only be used on a ReadableStreamDefaultController`)}function Gt(r,y,W){return I(r,W),W=>w(r,y,[W])}function Xt(r,y,W){return I(r,W),W=>w(r,y,[W])}function Jt(r,y,W){return I(r,W),W=>g(r,y,[W])}function Kt(r,y){if("bytes"!=(r=""+r))throw new TypeError(`${y} '${r}' is not a valid enumeration value for ReadableStreamType`);return r}function Zt(r,y){if("byob"!=(r=""+r))throw new TypeError(`${y} '${r}' is not a valid enumeration value for ReadableStreamReaderMode`);return r}function er(r,y){B(r,y);const W=null==r?void 0:r.preventAbort,j=null==r?void 0:r.preventCancel,A=null==r?void 0:r.preventClose,z=null==r?void 0:r.signal;return void 0!==z&&function(r,y){if(!function(r){if("object"!=typeof r||null===r)return!1;try{return"boolean"==typeof r.aborted}catch(r){return!1}}(r))throw new TypeError(y+" is not an AbortSignal.")}(z,y+" has member 'signal' that"),{preventAbort:!!W,preventCancel:!!j,preventClose:!!A,signal:z}}Object.defineProperties(It.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},desiredSize:{enumerable:!0}}),"symbol"==typeof j.toStringTag&&Object.defineProperty(It.prototype,j.toStringTag,{value:"ReadableStreamDefaultController",configurable:!0});class tr{constructor(r={},y={}){void 0===r?r=null:L(r,"First parameter");const W=$e(y,"Second parameter"),j=function(r,y){B(r,y);const W=r,j=null==W?void 0:W.autoAllocateChunkSize,A=null==W?void 0:W.cancel,z=null==W?void 0:W.pull,F=null==W?void 0:W.start,ee=null==W?void 0:W.type;return{autoAllocateChunkSize:void 0===j?void 0:N(j,y+" has member 'autoAllocateChunkSize' that"),cancel:void 0===A?void 0:Gt(A,W,y+" has member 'cancel' that"),pull:void 0===z?void 0:Xt(z,W,y+" has member 'pull' that"),start:void 0===F?void 0:Jt(F,W,y+" has member 'start' that"),type:void 0===ee?void 0:Kt(ee,y+" has member 'type' that")}}(r,"First parameter");if(or(this),"bytes"===j.type){if(void 0!==W.size)throw new RangeError("The strategy for a byte stream cannot have a size function");!function ke(r,y,W){const j=Object.create(fe.prototype);let n=()=>{},i=()=>c(void 0),a=()=>c(void 0);void 0!==y.start&&(n=()=>y.start(j)),void 0!==y.pull&&(i=()=>y.pull(j)),void 0!==y.cancel&&(a=r=>y.cancel(r));const A=y.autoAllocateChunkSize;if(0===A)throw new TypeError("autoAllocateChunkSize must be greater than 0");!function(r,y,W,j,A,z,F){y._controlledReadableByteStream=r,y._pullAgain=!1,y._pulling=!1,y._byobRequest=null,y._queue=y._queueTotalSize=void 0,ue(y),y._closeRequested=!1,y._started=!1,y._strategyHWM=z,y._pullAlgorithm=j,y._cancelAlgorithm=A,y._autoAllocateChunkSize=F,y._pendingPullIntos=new v,r._readableStreamController=y,h(c(W()),(()=>{y._started=!0,be(y)}),(r=>{Ee(y,r)}))}(r,j,n,i,a,W,A)}(this,j,Le(W,0))}else{const r=Me(W);!function(r,y,W,j){const A=Object.create(It.prototype);let i=()=>{},a=()=>c(void 0),s=()=>c(void 0);void 0!==y.start&&(i=()=>y.start(A)),void 0!==y.pull&&(a=()=>y.pull(A)),void 0!==y.cancel&&(s=r=>y.cancel(r)),Vt(r,A,i,a,s,W,j)}(this,j,Le(W,1),r)}}get locked(){if(!nr(this))throw ur("locked");return ir(this)}cancel(r=void 0){return nr(this)?ir(this)?d(new TypeError("Cannot cancel a stream that already has a reader")):ar(this,r):d(ur("cancel"))}getReader(r=void 0){if(!nr(this))throw ur("getReader");return void 0===function(r,y){B(r,y);const W=null==r?void 0:r.mode;return{mode:void 0===W?void 0:Zt(W,y+" has member 'mode' that")}}(r,"First parameter").mode?H(this):new Fe(this)}pipeThrough(r,y={}){if(!nr(this))throw ur("pipeThrough");M(r,1,"pipeThrough");const W=function(r,y){B(r,y);const W=null==r?void 0:r.readable;$(W,"readable","ReadableWritablePair"),Q(W,y+" has member 'readable' that");const j=null==r?void 0:r.writable;return $(j,"writable","ReadableWritablePair"),Ye(j,y+" has member 'writable' that"),{readable:W,writable:j}}(r,"First parameter"),j=er(y,"Second parameter");if(ir(this))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");if(Je(W.writable))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");return m(Bt(this,W.writable,j.preventClose,j.preventAbort,j.preventCancel,j.signal)),W.readable}pipeTo(r,y={}){if(!nr(this))return d(ur("pipeTo"));if(void 0===r)return d("Parameter 1 is required in 'pipeTo'.");if(!Xe(r))return d(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));let W;try{W=er(y,"Second parameter")}catch(r){return d(r)}return ir(this)?d(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")):Je(r)?d(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")):Bt(this,r,W.preventClose,W.preventAbort,W.preventCancel,W.signal)}tee(){if(!nr(this))throw ur("tee");const r=function(r,y){const W=H(r);let j,A,z,F,ee,re=!1,ie=!1,zt=!1;const Ft=u((r=>{ee=r}));function _(){return re||(re=!0,K(W,{_chunkSteps:r=>{ht((()=>{re=!1;const y=r,W=r;ie||Nt(z._readableStreamController,y),zt||Nt(F._readableStreamController,W)}))},_closeSteps:()=>{re=!1,ie||xt(z._readableStreamController),zt||xt(F._readableStreamController),ie&&zt||ee(void 0)},_errorSteps:()=>{re=!1}})),c(void 0)}function p(){}return z=rr(p,_,(function(y){if(ie=!0,j=y,zt){const y=ce([j,A]),W=ar(r,y);ee(W)}return Ft})),F=rr(p,_,(function(y){if(zt=!0,A=y,ie){const y=ce([j,A]),W=ar(r,y);ee(W)}return Ft})),b(W._closedPromise,(r=>{Qt(z._readableStreamController,r),Qt(F._readableStreamController,r),ie&&zt||ee(void 0)})),[z,F]}(this);return ce(r)}values(r=void 0){if(!nr(this))throw ur("values");return function(r,y){const W=H(r),j=new te(W,y),A=Object.create(Mr);return A._asyncIteratorImpl=j,A}(this,function(r,y){return B(r,"First parameter"),{preventCancel:!!(null==r?void 0:r.preventCancel)}}(r).preventCancel)}}function rr(r,y,W,j=1,A=(()=>1)){const z=Object.create(tr.prototype);return or(z),Vt(z,Object.create(It.prototype),r,y,W,j,A),z}function or(r){r._state="readable",r._reader=void 0,r._storedError=void 0,r._disturbed=!1}function nr(r){return!!o(r)&&!!Object.prototype.hasOwnProperty.call(r,"_readableStreamController")}function ir(r){return void 0!==r._reader}function ar(r,y){return r._disturbed=!0,"closed"===r._state?c(void 0):"errored"===r._state?d(r._storedError):(sr(r),p(r._readableStreamController[zr](y),t))}function sr(r){r._state="closed";const y=r._reader;void 0!==y&&(k(y),J(y)&&(y._readRequests.forEach((r=>{r._closeSteps()})),y._readRequests=new v))}function lr(r,y){r._state="errored",r._storedError=y;const W=r._reader;void 0!==W&&(C(W,y),J(W)?(W._readRequests.forEach((r=>{r._errorSteps(y)})),W._readRequests=new v):(W._readIntoRequests.forEach((r=>{r._errorSteps(y)})),W._readIntoRequests=new v))}function ur(r){return new TypeError(`ReadableStream.prototype.${r} can only be used on a ReadableStream`)}function cr(r,y){B(r,y);const W=null==r?void 0:r.highWaterMark;return $(W,"highWaterMark","QueuingStrategyInit"),{highWaterMark:D(W)}}Object.defineProperties(tr.prototype,{cancel:{enumerable:!0},getReader:{enumerable:!0},pipeThrough:{enumerable:!0},pipeTo:{enumerable:!0},tee:{enumerable:!0},values:{enumerable:!0},locked:{enumerable:!0}}),"symbol"==typeof j.toStringTag&&Object.defineProperty(tr.prototype,j.toStringTag,{value:"ReadableStream",configurable:!0}),"symbol"==typeof j.asyncIterator&&Object.defineProperty(tr.prototype,j.asyncIterator,{value:tr.prototype.values,writable:!0,configurable:!0});const dr=function(r){return r.byteLength};class fr{constructor(r){M(r,1,"ByteLengthQueuingStrategy"),r=cr(r,"First parameter"),this._byteLengthQueuingStrategyHighWaterMark=r.highWaterMark}get highWaterMark(){if(!_r(this))throw hr("highWaterMark");return this._byteLengthQueuingStrategyHighWaterMark}get size(){if(!_r(this))throw hr("size");return dr}}function hr(r){return new TypeError(`ByteLengthQueuingStrategy.prototype.${r} can only be used on a ByteLengthQueuingStrategy`)}function _r(r){return!!o(r)&&!!Object.prototype.hasOwnProperty.call(r,"_byteLengthQueuingStrategyHighWaterMark")}Object.defineProperties(fr.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),"symbol"==typeof j.toStringTag&&Object.defineProperty(fr.prototype,j.toStringTag,{value:"ByteLengthQueuingStrategy",configurable:!0});const br=function(){return 1};class pr{constructor(r){M(r,1,"CountQueuingStrategy"),r=cr(r,"First parameter"),this._countQueuingStrategyHighWaterMark=r.highWaterMark}get highWaterMark(){if(!yr(this))throw mr("highWaterMark");return this._countQueuingStrategyHighWaterMark}get size(){if(!yr(this))throw mr("size");return br}}function mr(r){return new TypeError(`CountQueuingStrategy.prototype.${r} can only be used on a CountQueuingStrategy`)}function yr(r){return!!o(r)&&!!Object.prototype.hasOwnProperty.call(r,"_countQueuingStrategyHighWaterMark")}function gr(r,y,W){return I(r,W),W=>w(r,y,[W])}function wr(r,y,W){return I(r,W),W=>g(r,y,[W])}function vr(r,y,W){return I(r,W),(W,j)=>w(r,y,[W,j])}Object.defineProperties(pr.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),"symbol"==typeof j.toStringTag&&Object.defineProperty(pr.prototype,j.toStringTag,{value:"CountQueuingStrategy",configurable:!0});class Sr{constructor(r={},y={},W={}){void 0===r&&(r=null);const j=$e(y,"Second parameter"),A=$e(W,"Third parameter"),z=function(r,y){B(r,y);const W=null==r?void 0:r.flush,j=null==r?void 0:r.readableType,A=null==r?void 0:r.start,z=null==r?void 0:r.transform,F=null==r?void 0:r.writableType;return{flush:void 0===W?void 0:gr(W,r,y+" has member 'flush' that"),readableType:j,start:void 0===A?void 0:wr(A,r,y+" has member 'start' that"),transform:void 0===z?void 0:vr(z,r,y+" has member 'transform' that"),writableType:F}}(r,"First parameter");if(void 0!==z.readableType)throw new RangeError("Invalid readableType specified");if(void 0!==z.writableType)throw new RangeError("Invalid writableType specified");const F=Le(A,0),ee=Me(A),re=Le(j,1),ie=Me(j);let ht;!function(r,y,W,j,A,z){function a(){return y}r._writable=function(r,y,W,j,A=1,z=(()=>1)){const F=Object.create(Ve.prototype);return Ge(F),bt(F,Object.create(_t.prototype),r,y,W,j,A,z),F}(a,(function s(y){return function(r,y){const W=r._transformStreamController;return r._backpressure?p(r._backpressureChangePromise,(()=>{const j=r._writable;if("erroring"===j._state)throw j._storedError;return jr(W,y)})):jr(W,y)}(r,y)}),(function u(){return function(r){const y=r._readable,W=r._transformStreamController,j=W._flushAlgorithm();return kr(W),p(j,(()=>{if("errored"===y._state)throw y._storedError;xt(y._readableStreamController)}),(W=>{throw Tr(r,W),y._storedError}))}(r)}),(function l(y){return function(r,y){return Tr(r,y),c(void 0)}(r,y)}),W,j),r._readable=rr(a,(function d(){return function(r){return qr(r,!1),r._backpressureChangePromise}(r)}),(function f(y){return Pr(r,y),c(void 0)}),A,z),r._backpressure=void 0,r._backpressureChangePromise=void 0,r._backpressureChangePromise_resolve=void 0,qr(r,!0),r._transformStreamController=void 0}(this,u((r=>{ht=r})),re,ie,F,ee),function(r,y){const W=Object.create(Er.prototype);let o=r=>{try{return Or(W,r),c(void 0)}catch(r){return d(r)}},n=()=>c(void 0);void 0!==y.transform&&(o=r=>y.transform(r,W)),void 0!==y.flush&&(n=()=>y.flush(W)),function(r,y,W,j){y._controlledTransformStream=r,r._transformStreamController=y,y._transformAlgorithm=W,y._flushAlgorithm=j}(r,W,o,n)}(this,z),void 0!==z.start?ht(z.start(this._transformStreamController)):ht(void 0)}get readable(){if(!Rr(this))throw Ar("readable");return this._readable}get writable(){if(!Rr(this))throw Ar("writable");return this._writable}}function Rr(r){return!!o(r)&&!!Object.prototype.hasOwnProperty.call(r,"_transformStreamController")}function Tr(r,y){Qt(r._readable._readableStreamController,y),Pr(r,y)}function Pr(r,y){kr(r._transformStreamController),gt(r._writable._writableStreamController,y),r._backpressure&&qr(r,!1)}function qr(r,y){void 0!==r._backpressureChangePromise&&r._backpressureChangePromise_resolve(),r._backpressureChangePromise=u((y=>{r._backpressureChangePromise_resolve=y})),r._backpressure=y}Object.defineProperties(Sr.prototype,{readable:{enumerable:!0},writable:{enumerable:!0}}),"symbol"==typeof j.toStringTag&&Object.defineProperty(Sr.prototype,j.toStringTag,{value:"TransformStream",configurable:!0});class Er{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!Cr(this))throw Wr("desiredSize");return Ht(this._controlledTransformStream._readable._readableStreamController)}enqueue(r=void 0){if(!Cr(this))throw Wr("enqueue");Or(this,r)}error(r=void 0){if(!Cr(this))throw Wr("error");var y;y=r,Tr(this._controlledTransformStream,y)}terminate(){if(!Cr(this))throw Wr("terminate");!function(r){const y=r._controlledTransformStream;xt(y._readable._readableStreamController),Pr(y,new TypeError("TransformStream terminated"))}(this)}}function Cr(r){return!!o(r)&&!!Object.prototype.hasOwnProperty.call(r,"_controlledTransformStream")}function kr(r){r._transformAlgorithm=void 0,r._flushAlgorithm=void 0}function Or(r,y){const W=r._controlledTransformStream,j=W._readable._readableStreamController;if(!Yt(j))throw new TypeError("Readable side is not in a state that permits enqueue");try{Nt(j,y)}catch(r){throw Pr(W,r),W._readable._storedError}const A=function(r){return!$t(r)}(j);A!==W._backpressure&&qr(W,!0)}function jr(r,y){return p(r._transformAlgorithm(y),void 0,(y=>{throw Tr(r._controlledTransformStream,y),y}))}function Wr(r){return new TypeError(`TransformStreamDefaultController.prototype.${r} can only be used on a TransformStreamDefaultController`)}function Ar(r){return new TypeError(`TransformStream.prototype.${r} can only be used on a TransformStream`)}Object.defineProperties(Er.prototype,{enqueue:{enumerable:!0},error:{enumerable:!0},terminate:{enumerable:!0},desiredSize:{enumerable:!0}}),"symbol"==typeof j.toStringTag&&Object.defineProperty(Er.prototype,j.toStringTag,{value:"TransformStreamDefaultController",configurable:!0})}}]);
//# sourceMappingURL=chunk.682.js.map