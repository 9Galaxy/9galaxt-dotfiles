"use strict";(globalThis.webpackChunkproton_pass_extension=globalThis.webpackChunkproton_pass_extension||[]).push([[684,881],{3881:(e,t,i)=>{i.r(t),i.d(t,{BigInteger:()=>BigInteger,default:()=>BigInteger});class BigInteger{static setImplementation(e,t=!1){if(BigInteger.Implementation&&!t)throw new Error("Implementation already set");BigInteger.Implementation=e}static new(e){return new BigInteger.Implementation(e)}}},8684:(e,t,i)=>{i.d(t,{default:()=>NativeBigInteger});var n=i(3881);class NativeBigInteger extends n.default{constructor(e){if(super(),void 0===e)throw new Error("Invalid BigInteger input");if(e instanceof Uint8Array){const t="0123456789ABCDEF";let i="";e.forEach((e=>{i+=t[e>>4]+t[15&e]})),this.value=BigInt("0x0"+i)}else this.value=BigInt(e)}clone(){return new NativeBigInteger(this.value)}iinc(){return this.value++,this}inc(){return this.clone().iinc()}idec(){return this.value--,this}dec(){return this.clone().idec()}iadd(e){return this.value+=e.value,this}add(e){return this.clone().iadd(e)}isub(e){return this.value-=e.value,this}sub(e){return this.clone().isub(e)}imul(e){return this.value*=e.value,this}mul(e){return this.clone().imul(e)}imod(e){return this.value%=e.value,this.isNegative()&&this.iadd(e),this}mod(e){return this.clone().imod(e)}modExp(e,t){if(t.isZero())throw Error("Modulo cannot be zero");if(t.isOne())return new NativeBigInteger(0);if(e.isNegative())throw Error("Unsopported negative exponent");let i=e.value,n=this.value;n%=t.value;let r=BigInt(1);for(;i>BigInt(0);){const e=i&BigInt(1);i>>=BigInt(1);const s=r*n%t.value;r=e?s:r,n=n*n%t.value}return new NativeBigInteger(r)}modInv(e){const{gcd:t,x:i}=this._egcd(e);if(!t.isOne())throw new Error("Inverse does not exist");return i.add(e).mod(e)}_egcd(e){let t=BigInt(0),i=BigInt(1),n=BigInt(1),r=BigInt(0),s=this.value,u=e.value;for(;u!==BigInt(0);){const e=s/u;let a=t;t=n-e*t,n=a,a=i,i=r-e*i,r=a,a=u,u=s%u,s=a}return{x:new NativeBigInteger(n),y:new NativeBigInteger(r),gcd:new NativeBigInteger(s)}}gcd(e){let t=this.value,i=e.value;for(;i!==BigInt(0);){const e=i;i=t%i,t=e}return new NativeBigInteger(t)}ileftShift(e){return this.value<<=e.value,this}leftShift(e){return this.clone().ileftShift(e)}irightShift(e){return this.value>>=e.value,this}rightShift(e){return this.clone().irightShift(e)}ixor(e){return this.value^=e.value,this}ibitwiseAnd(e){return this.value&=e.value,this}bitwiseAnd(e){return this.clone().ibitwiseAnd(e)}ibitwiseOr(e){return this.value|=e.value,this}equal(e){return this.value===e.value}lt(e){return this.value<e.value}lte(e){return this.value<=e.value}gt(e){return this.value>e.value}gte(e){return this.value>=e.value}isZero(){return this.value===BigInt(0)}isOne(){return this.value===BigInt(1)}isNegative(){return this.value<BigInt(0)}isEven(){return!(this.value&BigInt(1))}abs(){const e=this.clone();return this.isNegative()&&(e.value=-e.value),e}toString(){return this.value.toString()}toNumber(){const e=Number(this.value);if(e>Number.MAX_SAFE_INTEGER)throw new Error("Number can only safely store up to 53 bits");return e}getBit(e){return(this.value>>BigInt(e)&BigInt(1))===BigInt(0)?0:1}bitLength(){const e=new NativeBigInteger(0),t=new NativeBigInteger(1),i=new NativeBigInteger(-1),n=this.isNegative()?i:e;let r=1;const s=this.clone();for(;!s.irightShift(t).equal(n);)r++;return r}byteLength(){const e=new NativeBigInteger(0),t=new NativeBigInteger(-1),i=this.isNegative()?t:e,n=new NativeBigInteger(8);let r=1;const s=this.clone();for(;!s.irightShift(n).equal(i);)r++;return r}toUint8Array(e="be",t){let i=this.value.toString(16);i.length%2==1&&(i="0"+i);const n=i.length/2,r=new Uint8Array(t||n),s=t?t-n:0;let u=0;for(;u<n;)r[u+s]=parseInt(i.slice(2*u,2*u+2),16),u++;return"be"!==e&&r.reverse(),r}}}}]);
//# sourceMappingURL=chunk.684.js.map